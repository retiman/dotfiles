# Changes to the root directory of your git repository.  This must be a bash
# function; it cannot be a script.  Making it a script will change your cwd
# in the script, which will exit and accomplish nothing :)
function gitcd {
  pushd .
  while [ ! -d .git ]; do
    cd ..
    if [ $(pwd) = '/' ]; then
      echo 'Not in a git repo.' >&1
      popd
      return
    fi
  done
  popd
  cd -
}

# Decompress a file, so I don't have to keep in mind the specific flags I have
# to pass in for each program that does decompression.  This will blow away
# the original compressed file if the decompression succeeds, so be warned.
function decompress {
  if [[ "$1" = *.tar.bz2 ]]; then
    tar xvfj "$1" && rm "$1"
  elif [[ "$1" = *.tar.gz ]]; then
    tar xvfz "$1" && rm "$1"
  else
    case "${1##*.}" in
      zip)
        unzip "$1" && rm "$1";;
      gz)
        gunzip "$1" ;;
      rar)
        unrar x "$1" && rm "$1";;
      7z)
        7z x "$1" && rm "$1";;
      *)
        echo "Not a compressed file (that I know of)." ;;
    esac
  fi
}

# Colorize man pages.
man() {
  env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
    man "$@"
}

# Function for decrypting a file using AES; in case you wanted to use the file
# as a password store or something.
function decrypt {
  openssl enc -d -aes-256-cbc -salt -in "$1" -out "${1/.aes/}"
}

# Function for encrypting a file using AES; in case you wanted to use the file
# as a password store or something.
function encrypt {
  openssl enc -e -aes-256-cbc -salt -in "$1" -out "$1.aes"
}

# Functions for colorizing Bash prompt when working with Git or Mercurial
# repositories.
function gitparsedirty {
  MESSAGE="nothing to commit, working directory clean"
  [[ $(git status 2> /dev/null | tail -n1) != $MESSAGE ]] && echo "*"
}

function gitparsebranch {
  git branch --no-color 2> /dev/null |
  sed -e '/^[^*]/d' -e "s/* \(.*\)/\(\1$(gitparsedirty)\)/"
}

function hgparsedirty {
  [[ -n $(hg status 2> /dev/null | tail -n1) ]] && echo "*"
}

function hgparsebranch {
  local OUTPUT=$(hg branch 2> /dev/null)
  [[ -n $OUTPUT ]] && echo -n "($OUTPUT$(hgparsedirty))"
}

function repoparse {
  gitparsebranch
  hgparsebranch
}

# Copies vim project settings to a project using vim.  Project settings are
# based on language.
function vimproject {
    cp $HOME/.vim/project/${1}/project.vim .
}

# Colorize the Bash prompt the way I like it
function promptcolors {
  local BLUE="\[\033[0;34m\]"
  local RED="\[\033[0;31m\]"
  local GREEN="\[\033[0;32m\]"
  local WHITE="\[\033[1;37m\]"
  local CYAN="\[\033[0;36m\]"
  local PURPLE="\[\033[0;35m\]"
  local BROWN="\[\033[0;33m\]"
  local YELLOW="\[\033[1;33m\]"
  local LIGHT_BLUE="\[\033[1;30m\]"
  local LIGHT_RED="\[\033[1;31m\]"
  local LIGHT_GREEN="\[\033[1;32m\]"
  local LIGHT_GRAY="\[\033[0;37m\]"
  local LIGHT_CYAN="\[\033[1;36m\]"
  local LIGHT_PURPLE="\[\033[1;35m\]"
  local COLOR=$GREEN
  PS1="$COLOR[\u@\h:\W$RED\$(repoparse)$COLOR]\$\[\033[0m\] "
  PS2='> '
  PS4='+ '
}

# Add a directory to PATH if it's not already there.  Adds it to the 
# front of the PATH (uncomment to add to the end)
function addpath {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    #PATH="${PATH:+"$PATH:"}$1"
    PATH="$1:$PATH"
  fi
}
